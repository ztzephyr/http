[TOC]



## 一、O(nlogn)级排序算法







### 1.快速排序







#### 两路快排





```c++
#include <vector>
#include <random>

// 分区函数，调整数组中[lo, hi]区间的元素，返回数组中某个元素(基数)的下标, 并使得满足: 1.下标左侧元素<基数; 2.下标右侧元素>基数
int partition(vector<int>& nums, int lo, int hi) {    
    int pivot = nums[lo];	// 选择数组中第一个元素为基数
    int i = lo+1, j = hi;
    while(i<=j) {
        // i为左指针,自左向右比较, 目标为指向第一个大于基数的元素
        while(i<=hi && nums[i] <= pivot) {
            i++;	//i<=hi可避免越界！
        }
        // j为右指针,自右向左比较, 目标为指向第一个小于基数的元素
        while(j>lo && nums[j] > pivot) {
            j--;	
        }  
        // [lo+1, hi]区间内数据处理完成，跳出循环，准备最后交换， nums[j]为最后一个<=基数的元素
        if (i>=j) { break;}
        
        swap(nums[i], nums[j]);
    } 
    // 与基数交换 
    swap(nums[j], nums[lo]);
    return j;
}
void quickSort(vector<int>& nums, int lo, int hi) {
    // 终止条件：当前区域元素个数<=1时，不需排序
    if (lo >= hi) {
        return;
    }
	// 返回一个元素索引,满足:左侧小于该元素，右侧大于该元素
    int p = partition(nums, lo, hi);
    // 对左右区域分别排序
    quickSort(nums, lo, p-1);
    quickSort(nums, p+1, hi);
}
// 洗牌算法: 随机打乱数组nums
void shuttle(vector<int>& nums) {
    int n = (int)nums.size();
    default_random_engine e;	// 随机数引擎使用默认种子
    for (int i=0;i<n;i++) {
        // 从[i,n-1]中随机选取一个索引
        uniform_int_distribution<int> u(i, n-1);
        int r = u(e);
        swap(nums[i], nums[r]);
    }
}

void quickSort(vector<int>& nums) {
    shuttle(nums);
    quickSort(nums, 0, nums.size()-1);
}
```













#### 练习题

ld205.数组中的第K个最大元素





















### 2.归并排序



















## 二、O(n)级排序算法





































## 三、O(n2)级排序算法









#### |==冒泡排序











第一种写法：时间复杂度O(n2)

1.内循环：从左到右，一边比较一边交换，a[j]和a[j+1]没有往右移一位之前，将最大值放右边，待下次和新值比较。

2.外循环：总共要N-1轮，每1轮可以把当前未排序的元素，中的最大值放到最右边。











如果1个数组nums有N个元素，使用交换法的冒泡排序，执行n-1次可完成排序。每次，从index为0的元素开始，把当前未排序的元素，从左至右比较nums[j]和nums[j+1]，将较大值交换到j+1的位置，直到将最大值放到最右边。

```c++
// 总元素个数为N，重复N-1次；每次中，把未排序的列表中，最大的元素移动到最右边
vector<int> bubbleSort(vector<int>& nums) {
    // 要重复N次操作
    int N = nums.size();    /*返回vector中元素的个数*/
    // 重复N-1次
    for (int i = 0; i < N - 1; i++) {
        // 每次操作均从索引0开始，第i次操作时，剩下未排序的元素个数为N-i;索引j+1最大为N-i-1;
        for (int j = 0; j < N - i - 1; j++) {
            // 具体操作：比较当前元素和当前后一个元素大小，将较大的交换到右边
            if (nums[j] > nums[j + 1]) {
                swap(nums[j], nums[j + 1]);
            }
        }
    }
    return nums;
}
```



第二种解法：基于第一种进行优化

每次内循环，每次的2个元素，只要发生交换就说明不是有序；反之如果没有发生交换，那么这个未排序的列表其实已经有序了，因此：

1.申请1个变量，记录当前轮次(总共N-1轮)是否发生交换，如果没发生，不在排序，跳出外层for循环，直接认为已经完成了。这样可以优化一些。









#### |==选择排序



总共N-1,每次把最小的数放在最左边，剩下最后1个数字时肯定是最大的，此轮不需要了。

在每一轮中，将当前nums[i]和剩余未排序的，逐一比较，找到最小的数，记录index，最后把i和这个index交换。这样就把最小的数字

放在最左边了，



1.从左到右，总共进行N-1轮；

2.对于外循环的每一轮：申请变量minIndex，记录未排序的数中，最小的数的索引index

3.将最小的数交换到最左边；



```c++
// 选择排序
vector<int> selectSort(vector<int>& nums) {
    int N = nums.size(); 
    for (int i=0;i<N-1;i++) {
        // 记录最小的数的索引，开始默认是i,最小的数是nums[minIndex]
        int minIndex = i;
        
        // nums[i]和它右边的比较
        for(int j=i+1;j<N;j++) {
            if (nums[minIndex] > nums[j]) {
                // 出现更小的数,更新minIndex
                minIndex = j;
            }
        }
        
        // 将未排序列表中最小的数，交换在最左边
        int tmp = nums[i];
        nums[i] = nums[minIndex];
        nums[minIndex] = tmp;
    }
    return nums;
}
```



























#### |==插入排序

##### |=排序数组 Easy 912

插入排序超时！。

```c++
vector<int> sortArray(vector<int>& nums) {
    // 从第2个数开始，
    for (int i=1;i<nums.size();i++) {
        int curNumber = nums[i];
        int j = i -1;
        while (j >= 0 && curNumber <= nums[j]) {
            nums[j+1] = nums[j];
            j--;
        }
        // 碰到第一个比cur大的数，跳出循环
        nums[j+1] = curNumber;
    }
    return nums;
}
```

































