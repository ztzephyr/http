
- [泛型排序算法](#泛型排序算法)
- [基本使用方法](#基本使用方法)
- [元素排序原理](#元素排序原理)
- [定义谓词(比较函数)的几种方式](#定义谓词比较函数的几种方式)



#### 泛型排序算法

标准库提供的大多数算法定义在algorithom头文件中，但数值算法定义在头文件numeric头文件中。这些算法称为泛型算法，因为可以用于不同类型的元素和多种容器类型(包括数组)。




#### 基本使用方法



排序内置数组：

```c++
#include <algorithm> // 包含sort函数的头文件

using namespace std;

int main()
{
    int a[5] = {3, 1, 4, 1, 5};
    int n = sizeof(a) / sizeof(a[0]);
    sort(a, a + n);                   // 默认升序排序
    sort(a, a + n, greater<int>());   // 传递比较函数, 降序排序
    return 0;
}
```



排序vector容器：

```c++
#include <algorithm> // 包含sort函数的头文件
#include <vector>

using namespace std;

int main()
{
    vector<int> v = {3, 1, 4, 1, 5};
    sort(v.begin(), v.end());                 // 默认升序排序
    sort(v.begin(), v.end(), greater<int>()); // 传递比较函数, 降序排序
    return 0;
}
```



#### 元素排序原理



标准库中许多算法都会比较输入序列中的元素，默认情况下这类算法使用元素类型的<或=运算符完成比较，排序算法(sort)使用<运算符进行元素排序。那么，是如何使用<运算符进行排序的呢？

> 以标准库中提供的sort算法为例，可以认为算法永远将较小的元素排在前面。假设有两个元素a和b，对这两个元素执行<运算符，如果a<b结果为真，那么表示a需要排在b的前面，否则b排在a的前面。



此外，标准库也定义了额外版本，提供自定义的操作来代替默认运算符。例如，sort算法具有一个重载版本可接受第三个参数，该参数是一个谓词。接受一个二元谓词参数的sort版本用这个谓词代替<运算符，谓词的第一个参数表示<运算符的左操作数，第二个参数表示右操作数。这个谓词的返回结果就是<运算符的返回结果。

> 谓词，是一个可调用表达式，返回结果是一个能用作条件的值。二元谓词代表具有两个参数。



#### 定义谓词(比较函数)的几种方式



TODO: 可以在这里总的介绍一下有哪几种？以及C++中可以怎样定义可调用表达式




方式一，使用自定义比较函数：

```c++
#include <algorithm>
#include <vector>

using namespace std;

class Solution {
public:
    static bool isShorter(const string &a, const string &b) {
        return a.size() < b.size();
    }
    
    void customSort() {
        sort(words.begin(), words.end(), isShorter); // 使用自定义的比较函数进行排序
    }
private:
    vector<string> words = {"an", "a", "the"};
};
```

> 注意：在类中定义的 比较函数，需要声明为静态函数或全局函数。因为成员函数需要依赖于类的实例才能被调用，而 算法是一个全局函数，无法访问类的实例。





方式二，使用函数对象：

```c++
class Compare {
public:
    bool operator()(int a, int b) const {
        return a < b;
    }
};

std::vector<int> v = {3, 1, 4, 1, 5, 9, 2, 6, 5};
std::sort(v.begin(), v.end(), Compare());

// functional头文件中,定义了标准库函数对象模板
std::sort(v.begin(), v.end(), less<int>());          // 升序排序
std::sort(v.begin(), v.end(), greater<int>());       // 降序排序
```

> 可以使用struct代替class。如果使用class，需要加public。
>





方式三，使用lambda表达式：

```c++
auto cmp = [](int a, int b) -> bool {
    return  a < b;
};

std::vector<int> v = {3, 1, 4, 1, 5, 9, 2, 6, 5};
std::sort(v.begin(), v.end(), cmp);
```



方式四，使用function包装lambda表达式：

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

int main() {
    std::vector<int> v = {3, 1, 4, 1, 5, 9, 2, 6, 5};

    std::function<bool(int, int)> cmp = [](int a, int b) {
        return a > b;
    };

    std::sort(v.begin(), v.end(), cmp);   // 降序排序

    return 0;
}
```

