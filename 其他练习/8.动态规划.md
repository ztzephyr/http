

0-1背包 

给你一个可装载重量为W的背包和N个物品，每个物品有两个属性，重量和价值。第i个物品的重量用wt[i]表示，第i个物品的价值用val[i]表示。请计算，用这个背包装物品，最多能装的价值是多少？



题意(要做的事情) : 从[1,..N]个物品中，依次选择要不要装进背包。穷举所有可能情况，再穷举的时候更新最大价值。



1.明确状态和选择

状态： 可选的物品有哪些？  背包的空余容量剩多少？



选择：把这个物品装进背包 /  不装



2.根据状态，明确dp数组的定义

dp数组不为计算最后结果，只为表示当前状态(即这种情况下，你根据可做选择，去计算一种结果)

```c++
// dp[i][w]：当前状态(在第i个物品,背包空余容量为w) 
// 含义：对于只用前i个物品，当背包空余容量为w时，可装的最大价值为d[i][w]

// dp[0][...]=0: 对于只用0个物品，当前容量不管是什么，可装最大价值都为0
// dp[...][0]: 对于使用所有物品，当前容量为0，可装最大价值都为0
```



3.根据选择，写出状态转移逻辑

```c++
// 不把第i个物品放入背包: dp[i][w] = dp[i-1][w]

// 把第i个物品放入背包： dp[i][w] = val[i] + dp[i-1][w-wt[i]]
// val[i] 要表示的是第i个物品的价值，应用val[i-1]表示
// wt[i] 要表示第i个物品的重量, 应用wt[i-1]表示
```



```c++
int knapsack(int W, int N, vector<int>& wt, vector<int>& val) {
    // 定义dp数组， dp[i][w]表示在第i个物品下,背包剩余容量为w下，做出选择后,可装的最大价值
    vector<vector<int>> dp (N+1);

    // 如此定义则是按第1个物品开始计算的逻辑，i=0被表示成了没有物品的特殊情况;
    for (int i=0; i <= N; i++) {
        // 背包可装重量的每种情况
        for (int w=1;w<=W;w++) {
            // 背包容量不足，只能不装入
            if (w-wt[i-1] <= 0) {
                dp[i][w] = dp[i-1][w];
            } else {
                // 装入或者不装入背包，取价值大的
                dp[i][w] = max(
                        // 不把第i个物品装入背包
                        dp[i-2][w],
                        // 把第i个物品装入背包
                        val[i-2] + dp[i-1][w-wt[i-1]]
                );
            }
        }
    }
    return dp[N][W];
}
```































