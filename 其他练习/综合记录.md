

### 算法学习导读



常用数据结构： 数组/链表 、 栈 、 队列 、 二叉树



















### clion配置修改





```bash
# 关闭unuse的代码检查
编辑器 -- 检查 -- C/C++ -- 未使用的代码

# 关闭拼写检查
编辑器 -- 检查 -- 校对 -- 拼写错误
```





设置终端命令行为 git bash

```bash
# 设置 -- 工具 -- 终端 -- Shell路径 
"C:\Program Files\Git\bin\sh.exe" --login -i
```

























###### vector的定义及初始化问题



###### 数据类型最大最小值测试



###### 国内vscode下载缓慢问题

```c
https://az764295.vo.msecnd.net/stable/97dec172d3256f8ca4bfb2143f3f76b503ca0534/VSCodeUserSetup-x64-1.74.3.exe

替换为：

https://vscode.cdn.azure.cn/stable/97dec172d3256f8ca4bfb2143f3f76b503ca0534/VSCodeUserSetup-x64-1.74.3.exe
```



###### vscode设置vim快捷键

在vscode的键盘快捷方式设置中，搜索vim：Toggle Vim Mode， 然后设置指定的切换vim的快捷键











###### leetcode题目记录



##### 88、合并两个有序数组

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素

```c
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```



题目分析：这里把这个题放过来主要是为了练习双指针。给2个数组的最后放上指针，指向其最大的数，这里指的是数组1没有被延长时。这样只要指针不小于0,那就从后往前，依次比较，拿到较大的然后放到，延长后的数组一的最后面；稍微注意下，如果数组2没被用完，那么还得再来一个遍历，把数组2放完。如果数组1没被用完，数组2用完了，那不管了，因为1里面本来就排好了序。



知识点分析：go中for循环当while使用；



```go
func merge(nums1 []int, m int, nums2 []int, n int) {
   p1:=m -1  // 将p1指针放在nums1(未延长时)的末尾
   p2:=n-1   // 将p2指针放在nums2的末尾
   pos:=m+n-1 // 将pos指针放在nums1(被延长)的末尾

   for p1>=0 && p2>=0 {
      if nums1[p1] > nums2[p2] {
         // 由于2数组都是有序的，最后面的都是最大的数，p1指向的数更大，先放到最后一位，即pos指向的位置
         nums1[pos] = nums1[p1]
         p1--
         pos--
      } else {
         nums1[pos] = nums2[p2]
         p2--
         pos--
      }
   }
   
   // 若p2<0了，那么nums2排完了，nums1又是有序的不用排了
   // 若 p2>=0. 还需要把nums2里面的拿过来
   for p2>=0 {
      nums1[pos] = nums2[p2]
      pos--
      p2--
   }
}
```





##### 547、省份数量

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

```c
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
```



题目分析：这个题吧，要这么考虑，把n个城市都存进一个数组里，遍历数组依次处理。处理方法用深度优先遍历(DFS)该数组，用DFS的递归写法，当前节点时，深搜，一旦确定是同省份，将该城市标记，同时将省份数量加1。主函数依然是遍历，辅函数还是DFS递归去深搜当前节点的同省城市，以便主函数下次遍历到时直接跳过，省的浪费时间(因为你已经处理过了，将它并到某个省了)。辅函数要知道：你当前遍历到第几行，该行每列元素是否为1，该行是否被标记过



知识点：go切片定义；go匿名函数；



```go
func findCircleNum(isConnected [][]int) int {

   resCount:=0
   visit:=make([]bool, len(isConnected))

   // 辅函数
   var dfs func(visit []bool, isConnected[][]int, i int)
   dfs = func(visit []bool, isConnected [][]int, i int) {
      // 辅函数只管搜索该节点的，满足搜索规则的
      visit[i] = true
      for j:=0; j<len(isConnected);j++ {
         if isConnected[i][j] == 1 && !visit[j] {
            // 深搜到j是同省的，继续递归j
            dfs(visit, isConnected, j)
         }
      }
   }
   // 主函数
   for k:=0;k<len(visit);k++ {
      if !visit[k] {
         dfs(visit, isConnected, k)
         resCount++
      }
   }
   return resCount

}
```





##### 695、岛屿的最大面积

给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

```c
输入：[[0,0,1,0,0,0,0,1,0,0,0,0,0],
     [0,0,0,0,0,0,0,1,1,1,0,0,0],
     [0,1,1,0,1,0,0,0,0,0,0,0,0],
     [0,1,0,0,1,1,0,0,1,0,1,0,0],
     [0,1,0,0,1,1,0,0,1,1,1,0,0],
     [0,0,0,0,0,0,0,0,0,0,1,0,0],
     [0,0,0,0,0,0,0,1,1,1,0,0,0],
     [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```


对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。



题目分析：这个题是典型的DFS(深度优先遍历)，即以深度为第1关键词，每次都沿路径不能前进时，才退回路径的叉路口，这题里从元素为1的节点开始，上下左右为其路径，当非1时为不能前进，退回上1级接着沿路径。这里用了DFS的递归写法，首先明确递归的边界和处理方式：

1、遍历grid时超出范围，停止递归，即不在0<=i<len(grid)、0<=j<=len(grid[0])

2、当前节点为0，停止递归。这个地方判断当前节点是一定以索引ij未超过数组范围为前提

主函数就用来遍历每个节点，辅函数计算每个节点可构成的最大岛屿面积；在主函数中比较值得大小进而替代之；辅助函数在go中用匿名函数，即没有名字的函数。



知识点分析: go中使用匿名函数；go中遍历二维数组；go中小心数组越界；



```go
func maxAreaOfIsland(grid [][]int) int {
   res:=0
   // 辅函数：定义一个匿名函数 计算当前位置能构成的最大岛屿面积
   var dfs func(i, j int) int
   dfs = func(i, j int) int {
      // 该函数是个递归函数，分别递归计算出上下左右4个方向的节点能构成的最大岛屿面积
      // 递归结束条件1：超过二维数组的范围
      // 递归结束条件2：当前节点值为0,不能构成
      if i<0 || j<0 || i==len(grid) || j==len(grid[0]) || grid[i][j] !=1{
         return 0
      }
      //满足递归条件下，计算最大面积 上下左右相加
      grid[i][j] = 0
      return  dfs(i-1,j) + dfs(i+1, j) + dfs(i,j-1) + dfs(i, j+1) + 1
   }
   // 主函数：遍历二维数组
   for i:=0; i<len(grid); i++ {
      for j:=0;j<len(grid[0]);j++ {
         max:=dfs(i,j)
         if max > res {
            res = max
         }
      }
   }
   return res
}
```







##### 227、基本计算器II

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

```c
输入：s = "3+2*2"
输出：7
```



题目分析：此题首先默认最前面有个+号，表示你的结果，是要加上后面那串东西的。关键点要把乘除操作都转换成加减，要用一个辅助栈，在遍历字符串时，把每个符号右边的数都压栈，如果发现碰到了乘除算符，那么栈顶的那个元素要被替换掉，换成栈顶元素和下个数计算的结果，代替栈顶元素。这样，最后把栈顶的元素加起来即可。减算符的时候压栈一个负数就行。

知识点：go中使用slice做栈；go中判断字符是否为数字并计算；go中switch中的break机制要清楚；

题后分析：有点乱，下回分析

```go
func calculate(s string) int {

   var stack []int // 辅助栈，用来存结果，最后相加用
   num := 0        //
   op := '+'       // 用来记录数字前面的算符，第一个数默认前面是+
   ans := 0

   for i := 0; i < len(s); i++ {
      // 遍历的时候碰上数字字符串，转换成整数
      if isDigit(s[i]) {
         // 碰上是数字，记录下num(属于上个数)
         num = (num * 10) + int(s[i]-'0') //强制转换成int
      }
      // 碰到不是数字，而是算符，根据上个算符，把上个算符和它右边的数计算后压栈 此处到最后一个数的时候必须压栈，不必等下个算符
      if !isDigit(s[i]) && s[i] != ' ' || i == len(s)-1{
         // 此时的s[i]是下个算符,在此处用上个算符和数，与栈顶元素计算
         switch op {
         case '+':
            // 上个算符为+， 上个数记在num里
            stack = append(stack, num)
         case '-':
            stack = append(stack, -num)
         case '*':
            stack[len(stack)-1] *= num // 直接替换栈顶元素
         case '/':
            stack[len(stack)-1] /= num
         }
         // 上个num已经用过了，重置下, 算符更新下
         num = 0
         op = int32(s[i])
      }
   }
   for _, v := range stack {
      ans += v
   }
   return ans
}
```













##### 242、有效的字母异位词

给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。

**说明:**
你可以假设字符串只包含小写字母。

```c
输入: s = "anagram", t = "nagaram"
输出: true
```



题目分析：字符串专题训练。你可以用数组统计每个字符出现的次数，如果相等，那就是有效的，否则无效。这里有个小技巧优化，就是s出现某字符+1, t中出现某字符时可-1, 这样最后只需要判断数组中数组中是否有非0项，如果没有那就是有效的，否则无效。



知识点分析：go语言中定义数组；go中使用for循环遍历字符串；



题后分析：统一字符出现次数这个数组，可以用切片，但是要用make初始化切片大小，涉及知识点go中使用make初始化切片。拓展一个知识点，go中可以通过==判断两个数组是否相等，但是slice不行。

```go
func isAnagram(s string, t string) bool {
   // 考虑特殊情况，若两字符串长度不一样，肯定false
   if len(s) != len(t) {
      return false
   }
   var count [26]int // 使用数组，也可用slice，但记得用make初始化大小
   for i := 0; i < len(s); i++ {
      count[s[i]-'a']++
      count[t[i]-'a']--
   }
   // 简化成for range写法
   for _, v :=range count {
      if v != 0 {
         return false
      }
   }
   return true
}
```





##### 150、逆波兰表达式求值

根据[ 逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437)，求表达式的值。

有效的算符包括 `+`、`-`、`*`、`/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

-   整数除法只保留整数部分。
-   给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况

```c
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```





题目分析：根据经验，要使用一个辅助栈来保存操作数，栈中只保留2个操作数；输入是string切片，遍历时碰到算符的时候，计算辅助栈中的2个数，然后继续，直到结束



知识点：go中使用switch；go中使用for range循环；go中字符串转换成数字(strconv.Atoi的使用)；



```go
func evalRPN(tokens []string) int {
   var stack []int
   for i:=0; i<len(tokens);i++ {
      // 碰到算符前，占中操作数的个数
      l:=len(stack)
      switch tokens[i] {
      case "+":
      // 重新构造辅助栈, 切片qie[0:0], 算符只处理其左边两个元素
      stack = append(stack[:l-2], stack[l-2] + stack[l-1])
      case "-":
         stack = append(stack[:l-2], stack[l-2] - stack[l-1])
      case "*":
         stack = append(stack[:l-2], stack[l-2] * stack[l-1])
      case "/":
         stack = append(stack[:l-2], stack[l-2]/stack[l-1])
      default:
         // 非运算符时，将子串转化成数字，方便算符计算
         num, _ := strconv.Atoi(tokens[i])
         stack = append(stack, num)
      }
   }
   return stack[0]
}
```





##### 1221、分割平衡字符串

在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。返回可以通过分割得到的平衡字符串的 最大数量 。

注意：分割得到的每个字符串都必须是平衡字符串。

```c
输入：s = "RLRRLLRLRL"
输出：4
解释：s 可以分割为 "RL"、"RRLL"、"RL"、"RL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 
```



解答：字符串的遍历，遍历过程中，对字符操作；可以用一个指针去切割，切出来的字符串放在栈里；判断条件是栈顶元素为R,当前指针为L，满足则弹出栈去，栈空了说明找到了1个，第1次遍历栈肯定是空的，所以条件中栈不能空；然后继续；

关键点：栈顶元素如果和指针当前遍历的相等，那么就表示不平衡了，此时肯定继续append，等待下次不等，出栈，直到栈为空则找到了一个平衡字符串

知识点：定义go中的栈(切片)； 定义go中的循环；go中往栈添加元素；go中如何比较字符相等；

```go
func balancedStringSplit(s string) int {
   var stack []byte  // 使用切片作为栈，存储字符用byte
   var count int     // 记录返回结果

   length:=len(s)
   for i:=0;i<length;i++ {
      // 栈为空或栈顶元素与s[i]相同，则压栈; 否则出栈
      if len(stack) == 0 || stack[len(stack) - 1] == s[i] {
         stack=append(stack, s[i])
      } else {
         // 出栈，截取子长度，左闭右开
         stack = stack[:len(stack) - 1]
      }
      // 一次遍历中，进行处理后，判断stack是否为空，若空则成功分割1次
      if len(stack) == 0 {
         count++
      }
   }
   return count;
}
```



##### 621、任务调度器

给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 最短时间 。

**提示：**

-   `1 <= task.length <= 104`
-   `tasks[i]` 是大写英文字母
-   `n` 的取值范围为 `[0, 100]`



```c
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
```



题目分析：tasks数组(任务列表)，里面具有多种任务类型； CPU完成一个任务要1个单位时间；执行相同任务A中间必须间隔n个单位时间；根据题意大写字母最多26个，首先要遍历记录下每种任务的个数；如果1个1个执行任务，那么很容易碰到相同任务的时候，没有达到n的间隔时间，导致原地等待浪费时间；所以要合理安排一下！

第一种情况：任务种类数>n， 那么按照每种任务依次执行一般，这样每种任务执行间隔绝对大于n，又没有浪费时间，必定为最短的，这样算出，任务数量最多的那种类型A的数量为na, 还要设法算下和na相同的任务类型的数量，以下示例为A和B，额外+2；

A--B--C--A--B--X--A--B 这种情况X必须要待命，n=2,  

第二中情况：任务种类<n，这种情况种类比较少，必须会有待命x

A-B-X-X-A-B--X-X-A, n=3, 取决于数量最多的那种类型， na 

思路写的不好，后续改进下。



```go
func leastInterval(tasks []byte, n int) int {
   if n==0 {
      return len(tasks)
   }

   // 定义一个数组记录每种类型任务的个数
   count:=[26]int{0}  // 数组的创建和初始化的方式z

   // 定义1个变量记录数量最多的某种类型的任务的个数，初始假设为0
   maxNums:=0

   // 定义1个变量记录最后一个周期的额外处理的任务数
   extra:=0

   for i:=0;i<len(tasks);i++ {
      count[tasks[i]-'A']++
      // 每记录1次判断下，和当前最大数相比，该任务是否取代已记录的最大数
      if maxNums <  count[tasks[i]-'A'] {
         maxNums = count[tasks[i]-'A']
         extra=1
      } else if maxNums == count[tasks[i]-'A'] {
         //出现相等情况，意味着最后的+1多一个
         extra++
      }
   }
   res:= (maxNums - 1) * (n+1) +extra
   // 如果任务类型数院大于n,或许可以排列而不需要待命，这样最小时间可能为任务个数
   if len(tasks) > res {
      return len(tasks)
   }
   return res
}
```

































