- [前言](#前言)
- [反转整个链表的方法(迭代法)](#反转整个链表的方法迭代法)
- [反转链表指定索引区间\[left, right)的节点(迭代法)](#反转链表指定索引区间left-right的节点迭代法)





#### 前言

xxx



#### 反转整个链表的方法(迭代法)

假设有一个以head为头节点的链表，要反转整个链表，其实就是“反转节点head到nullptr之间的所有节点”。使用迭代法依次对每个节点的指向进行反转即可。

```c++
// leetcode-206, 反转以head为头节点的链表
ListNode* reverseList(ListNode* head) {
    ListNode *pre, *cur, *nxt;
    pre = nullptr; cur = head; nxt = nullptr;
    while (cur != nullptr) {
        nxt = cur->next;    // 提前记录下cur的下个节点
        cur->next = pre;    // 反转当前节点
        pre = cur;          // 更新指针位置
         cur = nxt;
    }
    return pre;
}
```





#### 反转链表指定索引区间[left, right)的节点(迭代法)



这是一个反转链表一部分问题，假设链表的头结点索引为1，要反转链表索引为left直到right之间的节点。

假设left对应的节点指针为cur,只需要不断的将cur后面的节点调换到它的前面，每次更新next节点，重复执行该操作righ-left次即可。

操作链表就是先断一条线，然后指向新的节点，此时新节点被多个指向，因此断开一条，继续指向别处

>   注意：反转链表的一部分，可能包括头节点，使用虚拟头结点解决这个问题

```c++
ListNode* reverseBetween(ListNode* head, int left, int right) {
    ListNode *dummy = new ListNode(0);
    dummy->next = head;

    ListNode *pre, *cur, *nxt;
    pre = dummy;
    for (int i = 0; i < left-1; i++) {
        pre = pre->next;            // 移动1次pre指向第1个节点, 则移动left-1次pre指向第left-1个节点
    }
    cur = pre->next;
    for (int i=0; i< right-left; i++) {
        nxt = cur->next;           // 每次操作都需要初始化一个新的nxt
        cur->next = nxt->next;
        nxt->next = pre->next;     // 不能使用cur代替pre->next，因为在多次操作中cur前面会插入调换来的元素，不能每次都指向cur
        pre->next = nxt;
    }
    return dummy->next;
}
```



也可以先取出链表一部分，反转后再接回去：

```c++
class Solution92 {
public:
    // 反转一个链表
    ListNode* reverse(ListNode* head) {
        ListNode *pre, *cur, *next;
        pre = nullptr; cur = head; next = head;
        while (cur != nullptr) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode *dummy = new ListNode(0);
        dummy->next = head;

        ListNode *pre, *cur, *nxt;
        pre = dummy;
        for (int i = 0; i < left-1; i++) {
            pre = pre->next;            // 移动1次pre指向第1个节点, 则移动left-1次pre指向第left-1个节点
        }

        // 再移动right-left+1次，到子链表最后一个节点
        ListNode *subListRightNode = pre;
        for (int i = 0; i < right-left+1; i++) {
            subListRightNode = subListRightNode->next;
        }

        // 提取子链表, 注意断开连接时记录信息
        ListNode* subListLeftNode = pre->next;
        pre->next = nullptr;
        ListNode* subRightNextNode = subListRightNode->next;
        subListRightNode->next = nullptr;

        reverse(subListLeftNode);     // 反转子链表

        pre->next = subListRightNode;
        subListLeftNode->next = subRightNextNode;

        return dummy->next;
    }
};
```

