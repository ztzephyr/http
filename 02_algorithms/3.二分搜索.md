





## 一、搜索元素及其边界



**二分搜索，是一种在<u>有序数组</u>中查找某一特定元素的搜索算法。**



### 1.查找一个数

​		最简单的场景，在一个有序的数组中(<u>元素无重复</u>)，查找某一特定元素(target)。当查找成功时返回对应元素索引，查找失败返回-1表示不存在元素target。

>   利用二分搜搜的思想：在一个有序的列表中，每次取中间值，与目标值(target)进行比较，从而缩小搜索空间，直到最后找到目标元素。

```c++
// 前提条件是有序数组
int binarySearch(vector<int>& nums, int target) { 
    int left = 0, right = (int)nums.size()-1;
    // 在[left, right]区间内搜索
    while(left <= right) {
        int mid = left + (right-left)/2;
        if (nums[mid] > target) {
            right = mid -1;		// 更新右侧边界
        } else if (nums[mid] < target) {
            left = mid + 1;		// 更新左侧边界
        } else if (nums[mid] == target) {
            return mid;
        }
    }
    return -1;
}
```



**1.二分搜索区间`[left, right]`的定义。**通过左右边界定义搜索空间，





循环条件中是<=，其取决于初始化的right，它决定了搜索区间，nums.size()-1表明需要在闭区间内搜索。

更新左右边界的时候，明确的知道mid索引对应的值和target的大小关系，综合搜索区间的概念，进行更新左右边界。



704.二分查找









### 2.查找左侧边界



```c++
int binarySearch(vector<int>& nums, int target) { 
    int left = 0, right = (int)nums.size()-1;
    // 在[left, right]区间内搜索
    while(left <= right) {
        int mid = left + (right-left)/2;
        if (nums[mid] > target) {
            right = mid -1;		// 更新右侧边界
        } else if (nums[mid] < target) {
            left = mid + 1;		// 更新左侧边界
        } else if (nums[mid] == target) {
            right = mid -1;
        }
    }
    
    // 检查出右边界和出左边界情况
    if (left>=nums.size() || nums[left] != target) {
        return -1;
    }
    
    return left;
}
```



while循环退出的三种情况：

**1.检查是否左边界持续更新到`left>=nums.size()`导致退出**。若`nums`中的元素全部小于目标值(target)，不断触发左边界更新`left++`，达到终止条件`left=right+1`后退出while循环。该情况未搜索到目标值(target)，在返回left之前若`left>=nums.size()`，则返回-1表示目标值(target)不存在。

**2.检查是否右边界持续更新直到`right=-1`导致退出。**若`nums`中的元素全部大于目标值(target)，不断触发右边界更新`right--`，达到终止条件`right=left-1`即为-1，然后退出循环。此时不能直接返回left，若`nums[left]!=target`则返回-1表示目标值(target)不存在。

**3.搜索到目标值(target)正常退出**。当找到一个目标值(target)时，即`nums[mid]==target`，会触发右边界刷新(认为该值不在最左侧)。不断刷新直到`nums[mid]<target`，此时右边界right刚好位于目标值(target)左侧边界的左边一位，然后会触发左边界刷新`left++`，达到终止条件`left=right+1`后会退出循环。此时left正好位于右边界right右边一位，即目标值(target)的左侧边界，直接返回left索引即可。

```c++
// 任何找到target的情况都会触发左右边界都刷新，以下条件去除后就是找到目标值的情况
if (left>=nums.size() || nums[left != target]) {
    return -1;
}
```





### 3.查找右侧边界



```c++
int binarySearch(vector<int>& nums, int target) { 
    int left = 0, right = (int)nums.size()-1;
    // 在[left, right]区间内搜索
    while(left <= right) {
        int mid = left + (right-left)/2;
        if (nums[mid] > target) {
            right = mid -1;		// 更新右侧边界
        } else if (nums[mid] < target) {
            left = mid + 1;		// 更新左侧边界
        } else if (nums[mid] == target) {
            left = mid + 1;
        }
    }
    
    // 检查出界情况
    if (right<0 || nums[right] != target) {
        return -1;
    }
    
    return right;
}
```



关注左右边界搜索到了的情况



**1.检查是否左边界持续更新到`left>=nums.size()`导致退出**。若`nums`中的元素全部小于目标值(target)，不断触发左边界更新`left++`，达到终止条件`left=right+1`后退出while循环。这种情况下要检查下`nums[right]!=target`是否成立，若不成立，则是左边界持续更新导致退出，返回-1。

**2.检查是否右边界持续更新直到`right=-1`导致退出。**若`nums`中的元素全部大于目标值(target)，不断触发右边界更新`right--`，达到终止条件`right=left-1`即为-1，然后退出循环。这种情况right=-1，只有没搜索到才会发生。判断right<0成立，则返回-1表示没找到。

3.。此时如果最右侧元素是target,那么也会触发左边界更新造成left=right+1，后退出循环，因此在左侧更新的情况下，要判断的是nums[right]!=target，如果这个成立即是左边界持续更新导致退出，而不是搜索到target正常退出。

右边界更新下，如果是遇到最左侧有target，也会立刻更新右边界，否则直至right更新为-1，所以判断-1可表明是右侧更新导致出界







## 二、进阶应用







