[TOC]









## 一、链表的构造



### 1.设计链表





```c++
// 链表节点：定义链表节点的数据结构
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr){};
};

// 链表类：提供创建及修改链表的方法
class MyLinkedList {

// 封装：仅允许类内进行访问
private:
    int size;
    ListNode* dummyHead;    
    
public:
    MyLinkedList() {
        dummyHead = new ListNode(0);    // 虚拟头结点
        size  = 0;
    }

    // 返回链表的头结点
    ListNode* getHead() {
        return dummyHead->next;
    }

    // 返回索引为index的节点值
    int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }
        // 获取指针, 指向索引为index的节点
        ListNode* p = dummyHead;
        for (int i=0;i<=index;i++) {
            p = p->next;
        }
        return p->val;
    }

    // 在头结点之前添加1个节点，成为新的头结点
    void addAtHead(int val) {
        ListNode* newHead = new ListNode(val);
        newHead->next = dummyHead->next;
        dummyHead->next = newHead;
        size++;
    }

    // 在尾节点后添加1个节点
    void addAtTail(int val) {
        ListNode* p = dummyHead;
        while(p->next!=nullptr) {
            p = p->next;
        }
        ListNode* tmp = new ListNode(val);
        p->next = tmp;
        size++;
    }

    // 在索引为index的节点之前插入1个节点; 另外，1.index<0,在头部插入节点. 2.index等于链表长度，在尾部插入节点.
    void addAtIndex(int index, int val) {
        if (index < 0) {
            addAtHead(val);
        } else if (index == size) {
            addAtTail(val);
        } else if (index > size) {
            return;
        } else{
            // 移动到到索引为index-1的节点,dummyHead->next为第1个节点
            ListNode* cur = dummyHead;
            for (int i=0;i<=index-1;i++) {
                cur = cur->next;
            }

            ListNode* tmp = new ListNode(val);
            tmp->next = cur->next;
            cur->next = tmp;
            size++;
        }
    }

    // 删除索引为index的节点
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }

        ListNode* cur = dummyHead;
        // 移动到索引为index-1的节点
        for (int i=0;i<=index-1;i++) {
            cur = cur->next;
        }
        cur->next = cur->next->next;
        size--;
    }


};

void printListNode(MyLinkedList::ListNode* head) {
    MyLinkedList::ListNode *p = head;
    while (p != nullptr) {
        cout << p->val << " ";
        p = p->next;
    }
    cout << endl;
}
```

























#### 一、合并拆解问题



##### |--合并2个有序链表  E21

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode *dummy = new ListNode(-1);
    ListNode *p = dummy;
    ListNode *p1 = list1, *p2 = list2;
    while (p1 != nullptr && p2 != nullptr) {
        if (p1->val < p2->val) {
            p->next = p1;
            p1 = p1->next;
        } else {
            p->next = p2;
            p2 = p2->next;
        }
        p = p->next;
    }
    if (p1 == nullptr) {
        p->next = p2;
    }
    if (p2 == nullptr) {
        p->next = p1;
    }
    return dummy->next;
}
```





##### |--删掉值为val的节点 E203

要删除1个链表中的节点，需要维护pre节点；所以遍历每次需要维护pre和更新cur即可。

1.采用虚拟头节点，以避免删除的是首节点。

```c++
ListNode* removeElements(ListNode* head, int val) {     
    ListNode *dummy = new ListNode(-1);
    dummy->next = head;
    ListNode *p = dummy->next;
    ListNode *pre = dummy;
    // 扫描链表
    while (p != nullptr) {
        // 出现要删除的元素
        if (p->val == val) {
            pre->next = p->next;
        } else {
            pre = p;
        }
        p = p->next;
    }
    return dummy->next;
}
```







##### |--找中间节点

使用指针必须保证非null，由于快指针移动到后面2个节点，因此fast->next必须不为null。对于1个链表，节点数为偶数情况下下，找到的是右侧中点。

```c++
ListNode* middleNode(ListNode* head) {
    ListNode *slow = head, *fast = head;
    // 快指针跳2步，慢指针跳1步(快指针最后有2种情况)
    while (fast!=nullptr && fast->next != nullptr) {
        fast = fast->next->next;
        slow = slow->next;
    }
    // 慢指针指向中点(节点数为偶数下中点为右侧)
    return slow;
}
```





##### |=找倒数第n个节点，并删除

设链表总节点数为n，fast指针先走k步，则剩余n-(k+1)个节点，fast走到null需要走n-(k+1)+1=n-k次，那么slow指针走过n-k次后，slow左边有n-k个节点，slow自己就是倒数第k个节点了.

```c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode *dummy = new ListNode(-1);
    dummy->next = head;
    // 虚拟头结点防止 要删除第1个节点，因为n+1
    ListNode *p = findNthFromEnd(dummy, n+1);
    p->next = p->next->next;
    return dummy->next;
}
ListNode* findNthFromEnd(ListNode* head, int k) {
    ListNode *slow = head, *fast = head;
    // 先让fast走k步
    for (int i = 0; i<k; i++) {
        fast = fast->next;
    }
    // 完成后slow就在倒数第n个节点上
    while (fast != nullptr) {
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}
```

>   找链表的倒数第k个节点，用快慢指针。快指针先走k步，然后fast不为null的情况下，一直走到底。最后，slow指向的就是倒数第k个节点。





##### |=排序链表中，删除多余的重复元素 Easy 83

fast指针探路，slow指针记录不重复元素。注意，slow记录最后1个元素时，其next可能连接着重复的元素，需手动指向null。

```c++
ListNode* deleteDuplicates(ListNode* head) {
    // 核心思想： fast指针探路，和slow不同时，记录结果，一次遍历即得到非重复
    if (head == nullptr) {
        return head;
    }
    ListNode *slow = head, *fast = head;
    while (fast != nullptr) {
        // fast跳到不重复的值，记录到slow链表中
        if (fast->val != slow->val) {
            slow->next = fast;
            slow = slow->next;
        }
        // fast右移到下一位
        fast = fast->next;
    }
    // 断开与后面重复元素的连接
    slow->next = nullptr;
    return head;
}
```



##### |=排序链表中，删除所有的重复元素 Medium 82

```c++
ListNode* deleteDuplicates(ListNode* head) {
    // 链表头节点可能重复而被删除，因此需要使用哑节点
    ListNode *dummy = new ListNode(-1, head);
    // 站在哑节点上判断
    ListNode *cur = dummy;
    while (cur->next != nullptr && cur->next->next != nullptr) {
        // 如果cur是重复节点
        if (cur->next->val == cur->next->next->val) {
            // 记录重复的值为x
            int x = cur->next->val;
            // 断开cur->next 直到连上不重复的值
            while (cur->next && cur->next->val == x) {
                cur->next = cur->next->next;
            }
        } else {
            cur = cur->next;
        }
    }
    return dummy->next;
}

```



##### |=链表分成k段 725 Medium

```c++
vector<ListNode*> splitListToParts(ListNode* head, int k) {
    // 计算链表长度
    ListNode* cur = head;
    int length = 0;
    while (cur!=nullptr) {
        length++;
        cur = cur->next;
    }

    // 计算每个子链表的平均长度和 剩余元素
    int aveLength = length/k;
    int remainder = length%k;

    vector<ListNode*> res;
    ListNode* p = head;
    ListNode* tail = nullptr;
    for (int i=0;i<k;i++) {
        //记录每段的头节点
        res.push_back(p);
        // 当前段子链表的长度
        int tempLength;
        if (remainder) {
            tempLength = aveLength + 1;
        } else {
            tempLength = aveLength;
        }
        for (int j=0;j<tempLength;j++) {
            // 每次记录，最后记录到尾节点
            tail = p;
            p = p->next;
        }
        // 若当前段不为空,断开尾结点
        if (tail) {
            tail->next = nullptr;
        }
        if (remainder) { remainder--; }
    }
    return res;
```





##### |= 根据特定值x重新排列链表节点 Medium 86

```c++
ListNode* partition(ListNode* head, int x) {
    // 两个链表指针
    ListNode *dummy1 = new ListNode(-1);
    ListNode *dummy2 = new ListNode(-1);
    ListNode *p1 = dummy1, *p2 = dummy2;
    ListNode *p = head;
    while (p != nullptr) {
        if (p->val >= x) {
            p2->next = p;
            p2=p2->next;
        } else {
            p1->next = p;
            p1 = p1->next;
        }
        // 临时变量
        ListNode *tmp = p->next;
        // 断开p的后续节点
        p->next =nullptr;
        p = tmp;
    }
    // 重新连接两条链表
    p1->next = dummy2->next;
    return dummy1->next;
}
```





##### |= 奇偶链表  Medium 328

将索引为奇数和偶数的节点分别组合在一起，然后返回。使用奇偶指针，奇指针连接偶指针下一个，直到最后。

```c++
ListNode* oddEvenList(ListNode* head) {
    if (head == nullptr) {
        return nullptr;
    }
    // 奇链表遍历指针
    ListNode *odd = head;
    // 偶链表遍历指针
    ListNode *even = head->next;
    // 记录下偶链表头， 后续连到奇链表尾
    ListNode *evenHead = head->next;
    // 使用指针必须保证指针不为null
    while (even != nullptr && even->next != nullptr) {
        odd->next = even->next;
        odd = odd->next;

        even->next = odd->next;
        even = even->next;
    }
    odd->next = evenHead;
    return head;
}
```





#### 二、反转问题

##### |--反转整个链表 E206

当你要重新调整p->next时(即重复赋值，指向新的节点)，注意之前指向的节点可能需要临时保存下来。

```c++
// 指针赋值==调整指针变量指向的内存单元实体
ListNode* reverseList(ListNode* head) {
    // 前1个节点,  当前节点
    ListNode *pre = nullptr, *cur = head; 
    while (cur != nullptr) {
        // 1.针对cur节点， 保存它下个节点
        ListNode *next = cur->next;
        // 2.当前节点指向pre节点
        cur->next = pre;     
        // 3. 更新pre给下次用
        pre = cur;
        // 4. 更新cur给下次用
        cur = next;
    }
    // 更新的pre就是最后一个节点
    return pre;
}
```



##### |--反转链表的前n个节点 

题目意思是反转链表的前n个节点，并返回新的头节点。

```c++
// 分解问题，递归解法
ListNode* successor;  // 用来记录不需反转的起点
ListNode* reverseN(ListNode* head, int n) {
    if (head == nullptr) {
        return head;
    }
     
    // base case
    if (n == 1) {
        // 记录下不需要反转的第1个节点
        successor = head->next;
        return head;
    }
    
    // 对于head->next来说，即反转前n-1个节点,并返回新的头结点
    ListNode* newHead = reverseN(head->next, n-1);
    // head->next为起点的链表反转后，head->next->next会指向nullptr,需修改指向head
    head->next->next = head;
    head->next = successor;
    return newHead;
}
```





##### |=反转第left到right的节点 M92

```c++
ListNode* reverseBetween(ListNode* head, int left, int right) {
    // 当left ==1就是反转前n个元素
    if (left == 1) {
        return reverseN(head, right-left+1);
    }
    // 对于head->next, 则为反转位置left-1到right-1的链表，并返回头节点
    head->next = reverseBetween(head->next, left-1, right-1);
    return head;
}

// 递归反转前n个节点
ListNode *successor;
ListNode *reverseN(ListNode* head, int n) {
    if (n == 1) {
        successor = head->next;
        return head;
    }
    // 返回新的头节点
    ListNode *newHead = reverseN(head->next, n-1);
    // 因为以head->next为起点反转n-1个节点，那么反转后head->next就是最后1个
    head->next->next = head;
    //递归到只反转前1个节点时，该节点就是新头节点，记录下他的下个节点,连到head后面
    head->next = successor;
    return newHead;
}
```



##### |=k个一组的反转链表 H25

```c++
ListNode* reverseKGroup(ListNode* head, int k) {
    ListNode *a=head, *b = head;
    // k个节点的区间
    for (int i = 0; i<k;i++) {
        if (b == nullptr) {
            // 不足k个，不需调整直接返回
            return head;
        }
        b = b->next;
    }
    ListNode *newHead = reverse(a, b);
    // 原来的头变成尾，连接剩下的链表(需要k个一组反转)
    a->next = reverseKGroup(b, k);
    return newHead;
}

// 反转[a,b)之间的链表，并返回头节点
ListNode* reverse(ListNode* a, ListNode* b) {
    ListNode *pre = nullptr, *cur=a;
    while (cur != b) {
        ListNode *next = cur->next;  // 记录cur的下个节点
        cur->next = pre;    // 调整cur的下个节点的指向
        pre = cur;          // cur搞好了, 将pre调整为指向cur
        cur = next;         // cur调整为指向临时记录的下个节点
    }
    // pre就是最后一个调整好的节点
    return pre;
}
```



##### |=判断链表是否回文 Easy 234

```c++
ListNode *left;
bool isPalindrome(ListNode* head) {
    left = head;
    return traverse(left);
}
// 倒序遍历链表
bool traverse(ListNode *right) {
    if (right == nullptr) {
        return true;
    }
    // 判断最后1个节点 是否等于第1个节点
    bool res = traverse(right->next);
    res = res && (right->val == left->val);
    // left右移
    left = left->next;
    return res;
}
```



















#### |==环形问题



##### |=判断一个链表是否有环 Easy 141

```c++
// 只要使用指针指向成员，就必须保证非空
bool hasCycle(ListNode *head) {
    ListNode *slow = head, *fast=head;
    while(fast != nullptr && fast->next != nullptr) {
        fast = fast->next->next;
        slow = slow->next;
        // 链表有环，快慢指针必相遇
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```



##### |=链表有环，找到环起点 Medium 142

如果有环，快慢指针必定会相遇。假设slow走了k，那fast就走了2k，k就是环的整数倍。再假如此时快慢指针距离环起点m个位置，那就是说，快指针现在只需要走k-m就会到环起点；然而慢指针从head出发走k-m就也会到环起点。所以slow指向head，fast不变，那么他们第一次相遇就是环起点。如果你说慢指针走的k步已经进了环若干圈，那么就把fast和slow一起退，直到slow不进圈。

```c++
ListNode *detectCycle(ListNode *head) {
    // 快慢指针从head出发
    ListNode *fast = head, *slow = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        // 出现相遇,那么有环
        if (slow == fast) {
            break;
        }
    }
    // 看下是不是有环, 无环返回null
    if (fast == nullptr || fast->next == nullptr) {
        return nullptr;
    }

    // 慢指针重新指向head
    slow = head;
    // 此时，有环若同步走若干步必相遇，且相遇点为环起点
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}
```





##### |=旋转链表 Medium

>   可以用找链表倒数第k个节点的方法， 链表连成环处理

```c++
// 右移链表的节点k个位置
ListNode* rotateRight(ListNode* head, int k) {
    // 没有节点或只有1个节点或不移动
    if (k==0 || head == nullptr || head->next == nullptr) {
        return head;
    }
    // 遍历求链表的长度以及尾节点
    ListNode *tail, *p = head;
    int n = 0;
    while (p != nullptr) {
        // 尾节点指针赋值
        tail = p;
        n++;
        p = p->next;
    }

    // 连接成环
    tail->next = head;

    // 移动的位置
    k = k%n;

    // 右移k个位置后,新链表最后一个位置为原链表倒数k+1个节点，即索引为n-(k+1)的节点
    // 找到该节点
    ListNode *p1 = head;
    for (int i = 0; i< n- k -1; i++) {
        p1 = p1->next;
    }

    // 调整head指针,最后一个位置下一个即为新head
    head =p1->next; 
    p1->next = nullptr;
    return head; 
}
```



















#### |==链表相交

##### |=判断2条链表是否相交 Easy 160

```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    // 无序hash set
    unordered_set<ListNode *> visit;
    // 用来遍历链表的指针
    ListNode *p1 = headA, *p2 = headB;
    while (p1 != nullptr) {
        visit.insert(p1);
        p1 = p1->next;
    }
    while (p2 != nullptr) {
        if (visit.count(p2)) {
            return p2;         
        } 
        p2 = p2->next;
    }
    return nullptr;
}
```





























