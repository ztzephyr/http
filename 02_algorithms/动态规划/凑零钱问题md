





```c++
int coinChange(vector<int>& coins, int amount) {
    // 明确状态： 1.可选的硬币列表  2. 剩余要凑的金额数
    // 明确选择： 选择coins中的一个元素
    // 定义状态转移函数： dp(coins, amount)表示使用coins数组中的硬币凑出amount金额需要的硬币最少个数
    // 写成状态转移逻辑: dp(coins[], amount) = dp(coins[i], amount-coins[i]) + 1

    // 记录需要的最少硬币个数,初始化为+00
    int res = amount+1;
    // 凑的金额为负数，那么凑不出来，返回-1
    if (amount < 0) { return  -1; }
    if (amount == 0) { return 0; }
    // 穷举每总情况
    for (int i=0;i<coins.size();i++) {
        // 计算凑amount需要的金额数
        int subProblem = coinChange(coins, amount-coins[i]) ;
        if (subProblem == -1) {
            continue;
        }
        // 更新需要的最少硬币个数
        res = min(res, subProblem+1);
    }
    // 当前凑amount凑不出来， 返回-1
    return res == amount + 1 ? -1 : res;
}
```



这么做超时！。









```c++
int dp(vector<int>& coins, int amount, vector<int>& mem) {
    // 明确状态： 1.可选的硬币列表  2. 剩余要凑的金额数
    // 明确选择： 选择coins中的一个元素
    // 定义状态转移函数： dp(coins, amount)表示使用coins数组中的硬币凑出amount金额需要的硬币最少个数
    // 写成状态转移逻辑: dp(coins[], amount) = dp(coins[i], amount-coins[i]) + 1

    // 过滤不可能凑出的值
    if (amount < 0) return -1;
    // 过滤凑金额为0的情况
    if (amount == 0) return 0;

    // 记录凑金额为amount需要的硬币最小个数,初始化为amount+1
    int res = amount + 1;

    // 查找备忘录
    if (mem[amount] != -66) {
        return mem[amount];
    }

    // 暴力穷举每种情况
    for (auto& coin : coins) {
        // 计算子问题: 凑金额为amount-coin需要的硬币最少数
        int subRes = dp(coins, amount-coin, mem);
        // 子问题凑不出来，则跳过该情况
        if (subRes == -1) continue;

        // 子问题可以凑出来，更新凑amount需要的硬币最少个数
        res = min(res, subRes + 1);
    }
    // 判断是否所有子问题均凑不出来?
    if (res == amount + 1) {
        mem[amount] = res;
        return -1;
    }
    // 记录当前结果到备忘录中
    mem[amount] = res;
    return mem[amount];
}
// 动态规划: 凑零钱
int coinChange(vector<int>& coins, int amount) {
    // 备忘录：记录凑每种金额需要的最小硬币数, 初始化为无效值-2
    vector<int> mem(amount+1, -66);

    return dp(coins, amount, mem);
}
```