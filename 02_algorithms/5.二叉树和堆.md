[TOC]



## 一、普通二叉树

#### |---基本操作



##### |--前/中/后序遍历  E144/E94/E145

前序遍历函数使用引用形参返回额外信息，即将节点值放置在数组中。可以看二叉树的遍历函数是没有返回值得。

```c++
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res;
    traverse(root, res);
    return res;
}
void traverse(TreeNode* root, vector<int> &res) {
    if (root == nullptr) {
        return;
    }
    // 前序遍历位置
    res.push_back(root->val);
    traverse(root->left, res);
    // 中序遍历位置
    traverse(root->right, res);
    // 后续遍历位置
}
```





##### 	|=层序遍历  Medium 102

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> res;
    if (root == nullptr) {
        return  res;
    }
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        vector<int> tmp =  vector<int>();
        // 遍历当前队列
        int size = q.size();
        for (int i=0;i<size;i++) {
            TreeNode* cur = q.front();
            q.pop();
            tmp.push_back(cur->val);
            // 更新下一层的节点
            if (cur->left != nullptr) {
                q.push(cur->left);
            }
            if (cur->right != nullptr) {
                q.push(cur->right);
            }
        }
        res.push_back(tmp);
    }
    return res;
}
```









##### |=最大深度 Easy 104

通过1次遍历得出答案，回溯思想。暴力的遍历每一条路径，走到base case的时候得到当前的depth。每走到一条路径的时候就更新一把结果到res，更新规则是看谁大。

```c++
// 记录最大的深度
int res;
// 记录遍历到的节点，当前的深度
int depth;
int maxDepth(TreeNode* root) {
    traverse(root);
    return res;
}
void traverse(TreeNode* root) {
    // base case 
    if (root == nullptr) {
        // 当前已经遍历过多条路径，res已经更新过很多次
        // depth 每次撤回时会减少
        res = max(res, depth);
        return;
    }
    depth++;
    traverse(root->left);
    traverse(root->right);
    depth--;
}
```



通过分解问题得出答案。最大深度可以通过子树的最大深度+1获得。

```c++
int maxDepth(TreeNode* root) {
    // base case : 节点为null，深度为0
    if (root == nullptr) {
        return 0;
    }
    // 左/右子树最大深度
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    int res = max(left, right) + 1;
    return res;
}
```





##### |=路径总和 Easy 112

计算是否存在根节点到叶子节点的路径，所有节点值总和为targetSum。

用1次遍历的方法，对每条路径都进行遍历，basecase是节点为null。对正在遍历的节点，进入时更新curSum，离开时更新curSum；若出现curSum==targetSum，若左右子树为null,那么就更新res为true。这样遍历完所有路径后，如果存在就可以得到res为true，否则为false。

```c++
// 记录结果
bool res = false;
// 记录遍历到的当前节点是，当前节点总和
int curSum = 0;
bool hasPathSum(TreeNode* root, int targetSum) {
    if (root == nullptr) {
        return false;
    }
    traverse(root, targetSum);
    return res;
}
void traverse(TreeNode* root, int targetSum) {
    // base case
    if (root == nullptr) {
        return;
    }
    // 前序遍历位置
    curSum += root->val;
    if (curSum == targetSum && root->left == nullptr && root->right == nullptr) {
        res = true;
    }
    traverse(root->left, targetSum);
    traverse(root->right, targetSum);
    curSum -= root->val;
} 
```



分解问题思想。

```c++
bool hasPathSum(TreeNode* root, int targetSum) {
    if (root == nullptr) {
        return false;
    }
	// base case
    if ( root->left == nullptr && root->right == nullptr) {
        return targetSum == root->val;
    }
	// 左右子树是否存在路径，目标和为targetSum-root->val
    return hasPathSum(root->left, targetSum-root->val) || 
    	   hasPathSum(root->right, targetSum-root->val);
}
```



##### |=根节点到叶子节点代表的数字总和 Meidum

用1次遍历

```c++
int res;
int curSum = 0;
int sumNumbers(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    traverse(root);
    return res;
}
void traverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 前序:进入节点是计算当前数值
    curSum = 10*curSum + root->val;
    if (root->left == nullptr && root->right == nullptr) {
        res += curSum;
    }
    traverse(root->left);
    traverse(root->right);
    curSum /= 10;
}
```





##### |=所有路径

返回所有根节点到叶子节点的路径。通过遍历1次二叉树的方式，用traverse函数配合外部变量实现。单独抽出一个节点，那么需要做的是记录当前的节点值。这里不过是按指定要求记录，使用前序遍历每次记录，遇到base case,就将当前结果记录到vector中。

```c++
// 
vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> res;
    traverse(root, res, "");
    return res;
}

void traverse(TreeNode* root, vector<string>& res, string curRes) {
    // base case
    if (root == nullptr) {
        return;
    }

    // 前序遍历位置
    curRes += to_string(root->val);
    if (root->left == nullptr && root->right == nullptr) {
        res.push_back(curRes);
    } else {
        curRes += "->";
    }

    traverse(root->left, res, curRes);
    traverse(root->right, res, curRes);
}
```





































##### |=翻转二叉树 Easy 226

使用一个遍历函数遍历每个节点。针对每个节点，需要交换左右子节点。可以在前/中/后序的时候都可以做。

```c++
/* 1.用一次遍历的思想解决 */
TreeNode* invertTree(TreeNode* root) {
    traverse(root);
    return root;
}
void traverse(TreeNode* root) {
    // base case
    if (root == nullptr) {
        return;
    }
    // 前序遍历：交换左右子节点
    TreeNode* tmp = root->left;
    root->left = root->right;
    root->right = tmp;
    
    traverse(root->left);
    traverse(root->right);
}

/* 2.用分解问题的思想解决*/
// 定义： 将以root为根的二叉树翻转，返回翻转后的根节点
TreeNode* invertTree(TreeNode* root) {
    // 使用分解问题的方式考虑
    // base case
    if (root == nullptr) {
        return nullptr;
    }
    // 对于左右子树也是：翻转
    TreeNode* left = invertTree(root->left);
    TreeNode* right = invertTree(root->right);
    // 交换左右节点，完成翻转
    root->left = right;
    root->right = left;

    return root;
}
```





##### |=二叉树的直径 Easy 543

就是每个节点左子树和右子树构成的就是一个直径，要遍历所有节点。遍历每个节点的时候，计算出当前节点的深度，以及左右子树深度。后序遍历可以知道当前节点的子树的深度情况，左右子树深度之和就是当前节点的直径，此时更新最大直径。

```c++
int maxDiameter = 0;
int diameterOfBinaryTree(TreeNode* root) {
    maxDepth(root);
    return maxDiameter;
}

// 计算当前节点的最大深度
int maxDepth(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    int leftMax = maxDepth(root->left);
    int rightMax = maxDepth(root->right);

    // 计算当前直径，更新最大直径
    maxDiameter = max(leftMax + rightMax, maxDiameter);
    return 1 + max(leftMax, rightMax);
} 
```





##### |=完美二叉树，填充每个节点的next指向右侧节点 Medium 116

```c++
Node* connect(Node* root) {
    // 使用1个遍历函数，每次遍历2个节点
    if (root == nullptr) {
        return nullptr;
    }
    traverse(root->left, root->right);
    return root;
}
void traverse(Node* node1, Node* node2) {
    if (node1 == nullptr || node2 == nullptr) {
        return;
    }
    // 每次遍历节点时， 需要做：
    node1->next = node2;
    
    traverse(node1->left, node1->right);
    traverse(node2->left, node2->right);
    traverse(node1->right, node2->left);
}
```



##### |=二叉树展开成 前序遍历的链表形式

```c++
// 定义：对每个节点来说，其展开成了一个单链表
void flatten(TreeNode* root) {
    // 使用分解问题的方法
    if (root == nullptr) {
        return;
    }

    // 1.将左右子树拉平
    flatten(root->left);
    flatten(root->right);
    TreeNode* left = root->left;
    TreeNode* right = root->right;

    // 2.将左子树作为右子树
    root->left = nullptr;
    root->right = left;

    // 3.从root遍历到底，将右子树接到左子树上
    TreeNode* p = root;
    while (p->right != nullptr) {
        p = p->right;
    }
    p->right= right;
}
```



#### |== 判断二叉树

##### |= 判断二叉树是否相同 100 Easy

分解问题的方法。定义递归函数，通过子问题的答案推导原问题得答案。

```c++
bool isSameTree(TreeNode* p, TreeNode* q) { 
    // base case
    if (p == nullptr && q == nullptr) {
        return true;
    }
    if (p == nullptr || q == nullptr) {
        return false;
    }
    if (p->val != q->val) {
        return false;
    }
    // 通过子问题的答案推导
    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```



##### |=判断二叉树是否对称 E101

两棵树，每次比较2个节点，

```c++
bool isSymmetric(TreeNode* root) {
    if (root == nullptr) {return true;}
    return check(root->left, root->right);
}
bool check(TreeNode* left, TreeNode* right) {
    if (left == nullptr || right == nullptr) {
        return left == right;
    }
    // 判断对称的俩个节点值
    if (left->val != right->val) {
        return false;
    }
    // 子问题
    return check(left->left, right->right) && check(left->right, right->left);
}
```









#### |==构造二叉树

##### |=用不重复的数组构建最大二叉树

分解问题。 先构造根节点，然后构建左子树，然后右子树，都是用数组中最大值构建。

```c++
TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
    return build(nums, 0, nums.size()-1);
}
TreeNode* build(vector<int>& nums, int lo, int hi) {
    // base case
    if (lo > hi) {
        return nullptr;
    }
    // 找一个数组中的最大值及其索引
    int index = lo;
    for (int i=lo;i<=hi;i++) {
        if (nums[i] > nums[index]) {
            index = i;
        }
    }
    TreeNode* root = new TreeNode(nums[index]);
    root->left = build(nums, lo, index-1);
    root->right = build(nums, index+1, hi);
    return root;
}
```



##### |=用前序和中序数组构造二叉树

分解问题。前序遍历，preOrder[0]是根节点；不含节点值得情况下，可以在中序数组中找到根节点的index，那么index左边是左子树，右边是右子树，可以计算出左右子树节点个数。

```c++
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    return build(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
}

// 根据前序数组和中序数组,返回当前根节点
TreeNode* build(vector<int>& preorder, int preStart, int preEnd, 
                vector<int>& inorder, int inStart, int inEnd) {
    // 补充base case
    if (preStart > preEnd) {
        return nullptr;
    }
    // 前序数组的第1个元素就是当前root节点
    int rootVal = preorder[preStart];
    TreeNode* root = new TreeNode(rootVal);
    // 用中序数组确定，左子树节点个数
    int index;
    for (int i=inStart;i<=inEnd;i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }
    int leftSize = index - inStart;
    // 递归构造左右子树的根节点
    root->left = build(preorder, preStart+1, (preStart+1)+(leftSize-1),
                       inorder, inStart, index-1);
    root->right = build(preorder, (preStart+1)+(leftSize-1)+1, preEnd,
                        inorder, index+1, inEnd);
    return root;
}
```





### 二叉搜索树(BST)



##### |=判断是否为二叉搜索树

BST(二叉搜索树)定义：对于每一个节点`root`，`root`的整个左子树都要小于`root->val`，root的整个右子树都要小于`root->val`.



分解问题，使用一个递归函数。约束条件传给每个子问题。对于root本身，无要求; root->left，就有max值,意味着此后的遍历到的各个子节点都是有此约束；root->right也是如此。

```c++
bool isValidBST(TreeNode* root) {
	// 定义一个递归函数，也是二叉树的遍历函数
    return traverse(root, nullptr, nullptr);
}

// 递归函数定义：返回以root为根的二叉树，是否是二叉搜索树
bool traverse(TreeNode* root, TreeNode* min, TreeNode* max) {
    //base case
    if (root == nullptr) {
        return true;
    }
    // 每个节点需要的处理
    if (min != nullptr && root->val <= min->val ) {
        return false;
    }
    if (max != nullptr && root->val >= max->val) {
        return false;
    }
    return traverse(root->left, min, root) && traverse(root->right, root, max);
}
```



##### |=在BST中找一个数

利用BST左小右大的特性，返回对应节点

```c++
TreeNode* findInBST(TreeNode* root, int target) {
    //base case
    if (root == nullptr) {
        return nullptr;
    }
    if (root->val == target) {
        return root;
    }
    if (root->val > target) {
        return findInBST(root->left, target);
    } else {
        return findInBST(root->right, target);
    }
}
```





##### |=能构造多少个不同的BST



```c++
int numTrees(int n) {
    vector<vector<int>> mem(20, vector<int>(20,0));
    return count(1,n, mem);
}

// 递归函数定义：计算由[lo, hi]构造的BST的个数
int count(int lo, int hi, vector<vector<int>>& mem) {
    // base case
    if (lo>hi) {
        return 1;
    }
    // 判断是否备忘录记录
    if (mem[lo][hi] != 0) {
        return mem[lo][hi];
    }
    int res = 0;
    for (int i=lo;i<=hi;i++) {
        // 假设i为root节点
        // 左子树只能由[lo, i-1]构成
        int left = count(lo, i-1, mem);
        int right = count(i+1, hi, mem);
        res += (left * right);
    }
    mem[lo][hi] = res;
    return res;
}
```









## 二、堆(优先队列)





最大堆：1.堆中某个节点的值总是不大于其父节点的值。2.堆总是一棵完全二叉树。

>   完全二叉树：这是一棵二叉树，除了最后一层节点之外，其他层所有节点个数必须是最大值，且最后一层所有的节点都必须集中在左侧。



使用数组构造二叉堆(最大堆)



堆顶节点的索引定为1，则如果某个数组时表示一个最大堆，那么可以根据数组的索引得到如下计算：

设当前节点的索引为i,

计算当前索引的节点的父节点的索引：parent(i) = i/2

计算当前索引的节点的 左节点索引： left_child(i) = 2*i

计算当前索引的节点的 右节点索引：right_child(i) = 2*i+1







































## 三、对二叉树的认识





二叉树有两种解题方式，一种是遍历的方式，一种是分解问题得方式。遍历方式的代表题目有.... ， 分解问题的代表题目有.... 。 

104的求二叉树的最大深度，遍历+外部变量方式解决，在叶子节点更新最大深度值。



543求二叉树的最大直径，分解问题的思想，后序遍历处理。



###### 利用前/中/后序数组，构造原来的二叉树



前序遍历数组： `[preOrderStart, preOrderEnd]`

1.根节点索引，preOrderStart；

2.左子树前序数组，起始索引为preOrderStart+1； 结束索引为 preOrderStart+前序数组元素个数(根据中序计算)

3.右子树前序数组，起始索引为，左子树结束索引+1； 结束索引为preOrderEnd；



中序数组：`[inOrderStart, inOrderEnd]`

1.根节点索引(用前序遍历的根节点计算出索引)， rootIndex；

2.左子树中序数组构造，起始索引为 inOrderStart;  结束索引为rootIndex-1(用前序数组计算根节点索引）;

3.右子树中序数组构造， 起始索引为(rootIndex+1)， 结束索引为inOrderEnd;



后序数组：`[postOrderStart, postOrderEnd]`

1.根节点索引，postOrderEnd;

2.左子树后序数组，起始索引为postOrderStart， 结束索引为`postOrderStart-1 + 左子树元素个数(用中序数组计算)`；

3.右子树后序数组，起始索引为`左子树后序数组结束索引+1`； 结束索引为`postOrderEnd-1`；



中+前： 终止条件是前；中+后：终止条件是中； 前+后：终止条件是前；